1.상속
====
1.상속의 정의
----
기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.

### 장점
    1. 보다 적은 양의 코드로 새로운 클래스를 작성할수있다. (코드 생산성 증가)
    2. 코드의 공통 관리를 통해 코드의 추가 및 변경이 매우 용이하다.(유지보수 수월)
    
**방법** : 클래스뒤에 extends 와 함께 상속받고자 하는 클래스 이름을 적으면 된다.   
   
    조상 클래스 : 부모클래스, 상위클래스(super), 기반클래스(base)
    자손 클래스 : 자식클래스, 하위클래스(sub), 파생클래스(derived)


### 2.클래스간의 관게 - 포함관계
  
포함관계를 맺어 주는것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조 변수를 선언하는것 이다.
   
   
Circle이라는 클래스에서 int x,y 를 지정하고 반지름 r을 설정할때
Point 클래스에서 int x,y 를 멤버변수로 선언하여 포함 시킬수 있다.
```java
class Circle{
    Point c = new Point();
    int r;
}
```


### 3.클래스간의 관계 설정하기

상송관계를 맺을 것인지 포함관게를 맺을 것인지 설정할때의 차이
### 포함관계
```
class Circle{
    Point c = new Point();
    int r;
}
```
### 상속관계
```
class Circle extends Point{
    int r;
}
```

상속의 경우 원의 점을 Point로 지정하여 준것이지만(점이 point 이다.)   
포함의 경우 원의 점중 하나를 point로 할수있게 만든것이다.(point를 가지고 있다.)   


### 4.단일상속

자바는 오직 단일 상속만 가능

2개이상의 클래스를 사용해서 새로운클래스를 작성해야되는 경우 단일상속을 사용하고 다른 클래스는 포함 시켜 사용할수 있다.


### 5.Object클래스

모든 클래스의 상속계층도 최상위에 위치한다.

상속받지 않는 클래스를 정의 할때 컴파일러에서 자동적으로 "extends Object"를 추가한다.

----
2.오버라이딩
----
### 1. 오버라이딩
    조상클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩 이라고 한다.   
    
```
class Point{
    int x;
    int y;
    
    String getLocation(){
        return "x:"+x+"y:"+y;
    }
}

class Point3D extends Point{
    int z;
    
    String getLocation(){ //오버라이딩
        return"x :"+x+", y :"+y+", z :"+z;
    }
```


### 2. 조건
#### 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
        - 이름이 같아야한다.
        - 매개변수가 같아야한다.
        - 반환타입이 같아야 한다.   
#### 1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
    - 보통 같은 접근제어자를 사용하지만 protected이면 protected혹은 public 이여야 한다.
    - 넓은 순에서 좁은순 : public, protected,(default),private
#### 2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
    -Exception의 경우 모든 예외의 최고 조상이므로 가장많은 갯수의 예외선언이기때문 오버라이딩에 사용될수없다.
#### 3. 인스턴스메서드를 static메서드로 또는 그 반대로변경할 수 없다.


### 3. 오버로딩
    오버로딩    : 기존에 없는 새로운 메서드를 정의 하는 것 
    오버라이딩  : 상속받은 메서드의 내용을 변경하는 것
    
### 4. super
super는 자손 클래스에서 조상 클래스로 부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.   

    this와 super는 근본적으로 같지만 같은이름의 멤버변수가 조상클래스 자손클래스에 있을때   
    super는 조상클래스의 this는 자손클래스의 멤버를나타낸다.

### 5. super() - 조상클래스의 생성자
    Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자,this() 또는 super(),를 호출해야 한다.    
    그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.
    
---
## 3. package와 import
---
### 1. 패키지
#### 클래스의 묶음
    - 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
    - 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
    - 패키지는 점(.)을 구분자올 하여 계츨구조로 구성할 수 있다.
    - 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.

### 2. 패키지의 선언
클래스나 인터페이스의 소스파일 맨위에 한줄만 적어주면 패키지의 선언이 된다.   
```
package 패키지명;
```

### 3. import문
다른 패키지의 클래스를 사용할때    

    클래스를 작성하기전 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면    
    소스코드에 사용되는 클래스의 이름에서 페키지명을 생략 가능하다.    


### 4. import문의 선언
소스파일의 구성   
    1. package문      
    2. import문      
    3. 클래스 선언      
   
import문의 선언 방법   
    ```
    import 패키지명.클래스명; 
    또는 
    import 패키지명.*;
    ```   
    클래스이름대신 " * " 을 사용할 경우 모든 클래스를 지정한다.   

### 5. static import문
static import문의 경우
    static멤버를 호출할때 클래스 이름을 생략할수 있다.
    
    
```
impot static java.lang.Integer.*;
impot static java.lang.Math.random;
impot static java.lang.System.out;
```   
과 같이 static import문을 선언해주었다면
아래와 같이 코드 변경이 가능하다.   
```
System.out.println(Math.random());
->
out.println(random());

```   
---
## 4.제어자
---
### 1. 제어자

    클래스,변수 또는 메서드의 선언부에 함께 사용되어 
    부가적인 의미를 부여한다.   
 
|접근제어자|그외|
|---|---|
|public|static|
|protected|final|
|default|abstract|
|private|natuve|
||transient|
||synchronized|
||volatile|
||strictfp|

### 2.static - 클래스의, 공통적인

static이 붙은 멤버변수와 메서드, 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기때문에    
인스턴스를 생성하지 않아도 사용 가능하다.   
|멤버변수|메서드|
|---|---|
|모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다.|인스턴스를 생성하지 않고도 호출이 가능한 static메서드가 된다.|
|클래스변수는 인스턴스를 생성하지 않고도 사용가능하다.|static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다|
|클래스가 메모리에 로드될때 생성된다.||

### 3. final- 마지막의 변경될수 없는
**거의 모든 대상에 사용될수있다.**
|대상|의미|
|---|---|
|클래스|변경될수없는 클래스, 확장될수 없는 클래스가 된다. 그래서 다른클래스의 조상이 될수없다.
|메서드|변경될 수 없는 메서드 오버라이딩을 통해 재정의 될 수 없다.|
|멤버변수,지역변수|값을 변경할수 없는 상수가 된다.|
   
### 4. abstract -추상의, 미완성의
    미완성의 의미를 가지고있기에
    메서드 선언부만 작성하고 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.

|대상|의미|
|---|---|
|클래스|클래스 내에 추상 메서드가 선언되어 있음을 의미한다.|
|메서드|선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.|
   
### 5. 접근 제어자

    멤버 또는 클래스에 사용 
    해당 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할

|제어자|접근가능|
|---|---|
|public|같은 클래스,패키지,자손클래스, 전체|
|protected|같은 클래스,패키지,자손클래스|
|(default)|같은 클래스,패키지|
|prinvate|같은 클래스|

---
## 5. 다향성
---

### 1. 다향성 
**조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다.**
       
    조상타입의 참조변수로 자손타입의 인스턴스를 참조할수있다.
    반대의 경우는 불가은하다.
    
### 2.참조변수의 형변환
- 자손타입 -> 조상타입(Up-casting) : 형변환 생략가능
- 조상타입 -> 자손타입(Down-casting): 형변환 생략 불가

### 3.instanceof연산자

인스턴스의 실제 타입을 알아보기위해 사용한다.   
주로 조건문에 사용되며   
boolean값으로 반환 된다.
참조변수 instaceof 타입 으로 작성한다.   

```
if(c instaceof Car)
```   
   
처럼 클래스를 타입으로 사용할경우 위와같이 된다.   
**어떤 타입에 대한 연산의 결과가 true라는 것은 검사한 타임으로 형변환이 가능하다는 것을 뜻한다.**   


### 4. 참조변수와 인스턴스의 연결
**멤버변수의 경우 참조변수의 타입에 따라 달라진다.**

    멤버변수가 조상클래스와 자손 클래스에 중복으로 정의된 경우. 
    조상타입의 참조변수를 사용했을떄는 조상클래스에 선언된 멤버변수가 사용되고
    자손타입의 참조변수를 사용했을때는 자손클래스에 선언된 멤버변수가 사용된다.
 


---
## 6. 추상클래스
---

### 1.추상클래스
클래스가 설계도라면 추상클래스는 미완성 설게도 이다.   
추상메서드를 가지고 있다는 의미이다.   
추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될수 있다.  

    키워드'abstract'를 붙이기만 하면 된다.   
    이렇게 붙여줌으로서 추상메서드가 포함되있어서 상속을 통해 구현해야한다는걸 알수있다.   

### 2. 추상메서드
선언부만 작성하고 구현부는 작성하지 않고 남겨둔 것 이 추상메서드 이다.   

구현부가 없으므로 괄호{} 대신 ;을 적어준다.     
```
/*어떤 기능을 할꺼였는지 설명을 적는 주석*/
abstract 리턴타입 메서드이름();
```   

추상클래스로 부터 상속받은 자손클래스는    
오버라이딩을 통해 추상클래스의 추상메서드를 모두 구현해 주어야 한다.   
**하나라도 구현이 안될시 자손클래스도 추상클래스로 지정해주어야 한다.**


### 3. 추상클래스 작성
    
    추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
    구체화 : 상속을 통해 클래스를 구현 확장하는 작업

```java
abstract class Player{
    boolean pause; // 일시정지 상태 저장 변수
    int currentPos; // 현재 play되고있는 위치 저장 변수
    
    Player(){ // 추상클래스도 생성자가 있어야 한다.
        pause = false; 
        currentPos = 0;
    }
    
    //지정 위치에서 재생을 시작하는 기능이 수행 되도록 작성 되어야 한다.
    abstract void play(int pos);//추상 메서드
     
    //재생을 즉시 멈추는 기능을 작성하여야 한다.
    abstract void stop();//추상 메서드
    
    void play(){
        play(currentPos);  추상메서드를 사용할수있다.
    }
    
    void pause(){
        if(pause) { // pause가 true 일때 (정지상태)에서 pause가 호췰되면
            pause = false;// pause의 상태를 false로 바꾸고
            play(currentPos);//현재의 위치에서 play한다.
        } else{ //pause가false 일때 (정지상태)에서 pause가 호췰되면
            pause = true;//pause의 상태를 true로 바꾸고
            stop();//play를 멈춘다.
        }
    }
}

```
Plater추상 클래스를  play와 stop 추상 메서드를 작성하여 만들었다.     
위 추상 클래스를 조상으로 받아 자손클래스를 만든 예시이다.
```java
class CDPlayer extends Player{
    void play(int currentPos){
        /*조상의 추상메서드를 구현 내용 생략*/
    }
    void stop(){
        /*조상의 추상메서드를 구현 내용 생략*/
    }
    
    //CDPlayer클래스에서 추가로 정의된 멤버
    int currentTrack; // 현재 재생중인 트랙
    
    void nextTrack(){
        currentTrack++;
        //생략
    }
    void preTrack(){
        if(currentTrack>1){
             currentTrack--;
        }
        //생략
    }
    
}

```
조상의 추상메서드를 기능에 맞게 완성을 하고 새로운 기능또한 추가 하였다.       
아무내용없이 {}만 쳐주어도 play와 stop메서드를 일반메서드로 간주할수있다.      

굳이 추상메서드를 사용하여 자손클래스에서 오버라이딩 하여 구현 하는것이 쓸데없을수 있지만    
추상메서드부분을 지정하여 두는것으로 꼭 메서드를 작성해야된다는 **강제를 할수있기** 때문이다.    





---
## 7. 인터페이스
---

### 1, 인터페이스
일종의 추상클래스로 추상도가 더 높아서    
오직 **추상메서드** 와 **상수**만 멤버로 가질수 있다.
    
다른 클래스를 작성하는대 **도움**을 줄 목적으로 작성된다    
    
    
### 2.작성

```
interface 인터페이스이름{
    public ststic final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);
}
   

```
   
**제약사항** 
    - 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
    - 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.


생략 가능한 이유는 인터페이스에 정의된 멤버는 상우 public static final이여야하고      
메서드는 추상메서드인 public abstract 이여야함으로 생략할수있다.     
생략할 경우 컴파일시 컴파일러가 자동적으로 추가한다.

    
### 3.인터페이스 상속

1. 인터페이스는 인터페이스로부터만 상속 받을수있다.
2. 다중상속이 가능하다.
 
### 4. 인터페이스 구현
추상클래스처럼 인터페이스 자체로는 인스턴스 생성을 할수없음   

추상메서드의 구현부를 만들 클래스를 작성하게된다.
extends가 아닌 implements를 사용하여
```java
class 클래스이름 implements 인터페이스이름{
    //인터페이스에 정의되어 있는 추상메서드 구현
}
```

만일 일부 메서드만 구현 했다면 abstract를 붙여 추상클래스로 선언해야함   


### 5. 장점 
- 개발시간의 단축
- 표준화 가능
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있음
- 독립적인 프로그래밍 가능


---
## 8.내부 클래스
---
### 1. 내부 클래스
클래스안에서 선언된 클래스   

**장점**
    - 내부 클래스에서 외부클래스의 멤버들을 쉽게 접근할 수 있다.
    - 코드의 복잡성을 줄일수 있다(캡슐화)

### 2. 내부클래스의 종류와 특징

1. 인스턴스 클래스         
 - 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버 처럼 다루어 진다.   
    주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다.        
2. 스태틱 클래스
  - 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static 멤버 처럼 다루어진다.
3. 지역 클래스
  - 외부 클래스의 메서드나 초기화 블럭 안에 선언하며, 선언된 영역 내부에서만 사용될수있다.
4. 익명 클래스
  - 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스

### 3. 내부 클래스 선언
```
class Outer{
    int iv = 0;
    static int cv = 0;
    
    void myMethod(){
        int lv = 0;
    }
}
```
위와 같은코드를 
```
class Outer{
    class InstanceInner{}
    static class StaticInner{}
    
     void myMethod(){
       class LocalInner{}
    }
}

```
와 같이 내부 클래스로 선언 가능하다.


### 4. 내부클래스의 제어자와 접근성
내부클래스도 클래스이기 때문에   
    
    abstract나 final과같은 제어자들과 
    멤버변수처럼 private,protectrd과 접근제어자도 사용이 가능하다.
    
### 5. 익명 클래스

    이름이 없고 클래스의 선언과 객체의 생성을 동시에 하기 때문에 
    단 한번만 사용될수 있고 오직 하나의 객체만을 생성하는 일회용 클래스이다.
    
    
**이름이없기에 생성자또한 없다.**
    
 
