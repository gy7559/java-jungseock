# 컬랙션 프레임웍
## 1. 컬렉션 프레임웍
**데이터 군 을 저장하는 클래스들을 표준화한 설계**       
컬렉션,다수의 데이터를 다루는대 팔요한 많은 클래스들을 제공해줌     
객체지향적 설계를 통해 표준화 되어 익히기 쉽고 재사용성높은 코드를 작성할수있다.    


### 1. 핵심 인터페이스
컬렉션 데이터 그룹은 크게 3가지로 나뉨    
1. List
2. Set
3. Map
여기서 List와 Set의 공통부분을 가져와서 Collection을 추가로 정의 하여      
컬렉션 프레임웍 의 인터페이스로 정의하였다.

|인터페이스|특징|
|---|---|
|List|순서가 있는 데이터의 집합. 데이터의 중복을 허용함|
|Set|순서를 유지하지 않는 데이터의 집합. 중복을 허용안함|
|Map|키 와 값을 쌍으로 이루어진 데이터의 집합. 순서유지X 키=중복X 값=중복O|


**Collection인터페이스**
|메서드|설명|
|---|---|
|boolean add(object o)|지정된 객체(o)를 Collection에 초가한다.|
|void clear()|Collection의 모든 객체를 삭제한다.|
|boolean remove(Object o)|지정 객체 삭제|

등 여러 메서드가 존재한다.

**List 인터페이스**
중복을허용하고 저장순서를 유지하는 컬렉션을 구현하는대 사용된다.
|메서드|설명|
|---|---|
|Void add(int index, Object element),boolean addAll(int index, Collection c) |지정된 위치(index)에 객체 또는 컬렉션에 포함된 객체들을 추가한다.|
|int indexOf(Object o)|지정된 객체의 위치 반환|
|Object remove(int index)|지정 위치에 있는 객체를 삭제하고 삭제된 객체를 반환|

등 여러 메서드가 존재

**Set인터페이스**
중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 구현 하는대 사용된다.     
구현한 클래스로는 HashSte,TreeSet등이 있다.     


**Map인터페이스**
키와 값을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는대 사용된다.        
Hashtable, HashMap,LinkedHashMap,SortedMap, TreeMap등이 있다.         


### 2.ArrayList

컬렉션 프레임웍에서 가장 많이 사용되는 컬렉션 클래스이다.      
List인터페이스를 구현  List의 특징을 가진다.

   장점 : 구조가 간단하며 사용하기 쉽다.
          데이터를 읽어오는대 걸리는 시간이 가장 빠르다.
   단점 : 크기를 변경할수 없다.
           비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.
           
위와 같은 단점으로 크기를 변경하여 주기 위해서는 더큰 배열을 만든후 복사를 하여야 하며,     
중간의 데이터를 추가 하기 위해서는 다른 데이터를 복사해서 이동해서 빈자리를 만들어야 한다.    



### 3. LinkedList
배열의 단점을 보완하기위해서 LinkedList라는 자료구조가 고안 되었다.      

데이터를 서로 연결한 형태로 되어있다.
각 요소들이 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 이루어져 있다.     
중간에 새로운 요소가 들어올경우 새로운 값의 주소를 이어질 전 요소에 입력하고      
다음 요소의 주소를 넣을 요소에 넣어주면 되어 속도가 바르다.

하지만 단방향이기때문에 다음요소에 대한 접근은 쉽지만 이전 요소에 대한 접근은 힘들다.      
그단점을 보완 하기 위해 더블 링크드 리스트를 만들었다.     
간단하게 이전 요소의 주소도 가지고있는 링크드 리스트이다.

 
 |컬랙션|읽기|추가/삭제|비고|
 |---|---|---|---|
 |ArrayList|빠르다|느리다|순차적인 추가삭제는 더 빠름.|
 |LinkedList|느리다|빠르다|데이터가 많을수록 접근성이 떨어짐|
 
 
 
 ### 4. Stack과 Queue
 
        Stack : 마지막에 저장한 데이터가 먼저나오는 구조
        Queue : 처음저장한 데이터가 먼저 나오는 구조
               
 
데이터를 추가/삭제가 쉬운 LinkedList가 적합하다.      


**활용**

   스택 :  수식 계산,수식돨호검사,웹브라우저의 뒤로/앞으로
   큐 : 최근사용문서 인쇄작업 대기목록, 버퍼
   
**Queue의 변형**

1. PriorityQueue
         저장 순서에 상관없이 운선숭위가 높은것부터 꺼낸다.
2. Deque
         한쪽 끝으로만 추가 삭제가 가능하다.
         끝에저장,삭제(offerLast,pollLast)
         앞에 저장,앞에 삭제(offerFirst,pollFirst)
    
    
    
### 5. Iterator, ListIterator, Enumeration
컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스      
Enumeration = Iterator의 구버전,ListIterator = Iterator의 향상     


Iterator는  요소를 읽어오는 방법을 표준화 하였으며
메서드로는 
|메서드|설명|
|---|---|
|boolean hasNext()|읽어올 요소가 남아 있는지 확인한다. 있으면 true,없으면 false를 호출|
|Object next()|다음요소를 읽어온다.|
|void remove()|next로 읽어온 요소를 삭제한다.|



 Enumeration은 프레임웍이 만들어지기 이전에 사용하던것으로 호환을 위해 남겨둔것이라 Iterator를 사용하면된다.     

 ListIterator는 List인터페이스를 구현한 경우에 양방향으로 이동이 가능하게 만들어둔것이다.     
 
 ListIterator 의 메소드는  Iterator메소드에서 이전 요소에대한 접근도 추가 되었다.      
 
 
 ### 6. Arrays
 배열을 다루는데 유용한 메서드가 정의 되어 있다.
 
 **배열의 복사**      
      coptOf()     : 배열의 전채 복사
      copyOfRange()  : 배열의 특정 부분 복사    
      
**배열 채우기**
      fill()   : 모든 요소를 지정된 값으로 채운다.
      setAll() : 배열을 채우는데 사용할 함수형 인터페이스를 받는다.
 
**배열의 정렬과 검색**
      sort()   : 배열의 정렬
      binarySearch() : 배열에 저장된 요소 검색(단 배열이 정렬되어 있어야함)
 
**배열의 비교와 출력**
      equals()    : 두배열을 비교하여 값으면 true 다르면 false를 출력 
      toSting()   : 배열의 모든 요소를 문자열로 출력 가능
      둘다 다차원 배열에서는 deep을 붙여주어 사용 deepToString(), deepEquals()
      
**베열을 List로 변환**
      asList() 배열을 List로 변환 가능하지만 삭제및 추가가 불가능하다.
               내용의 변경은 가능하다.
