1.객체지향언어
====
### 1. 객체 지향언어
	"실제 설계는 사물(객체)로 이루어져 있으며 발생하는 모든 사건들은 사물간의 상호작용이다."   

### 2. 주요특징
    1. 코드의 재사용성이 높다.   
       - 새코드 작성시 기존코드를 이용하여 쉽게 작성가능   
    2. 코드의 관리가 용이하다.   
       - 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드 변경이 가능   
    3. 신뢰성이 높은 프로그래밍이 가능.   
       - 제어자와 메서드를 이용해서 데이터를 보호하고 값을 유지하도록하며   
	코드의 중복을 제거하여 코드 불일치로 인한 오동작 방지가능   

---
## 2. 클래스와 객체
---
 ###  1. 정의와 용도
 클래스   
	-정의 : 클래스란 객체를 정의해 놓은 것이다.   
	-용도 : 객체를 생성하는대 사용된다.

객체   
	-정의 : 실제로 존재하는것. 사물 또는 개념      
	-용도 : 객체가 가지고 있는 기능과 속성에 따라 다름   
	
	- 유형의 객체 : 책상, 의자, 자동차 와 같은 사물   
	- 무형의 객체 : 수학공식, 프로그램 에러와 같은 논리나 개념   
 
###  2. 객체와 인스턴스
인스턴스   
	클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화 라고 한다.   
	클래스로 부터 만들어진 객체를 그 클래스의 인스턴스 라고한다.   

###   3. 객체의 구성요소
속성과 기능   
	속성 : 멤버변수, 특성, 필드, 상태   
	기능 : 메서드,함수,행위   

###   4. 인스턴스의 생성과 사용

```
	클래스명 변수명;	//클래스의 객체를 참조하기위한 참조변수를 선언   
	변수명 = new 클래스명(); //클래스의 객체를 생성후, 객체의 주소를 참조변수에 저장   
	Tv t;
	t = new Tv();
```	
__참조변수를 통해서만 다룰 수 있으며,참조변수의 타입은 인스턴스의 타입과 일치해야한다.__
    
### 5. 객체배열

	많은 수의 객체를 다룰때 배열로 다루면 편리하다.   
	그것을 객체배열 이라한다.
```	
	Tv[] tvArr = nrw Tv[3];
```
###  6. 클래스의 또 다른 정의
	1. 변수	: 데이터 저장 공간
	2. 배열	: 같은 종류의 여러 데이터를 하나의 집합으로 저장할수있는 공간
	3. 구조체	: 종류관계없이 여러 데이터를 하나의 집합으로 저장할수있는 공간
	4. 클래스 	: 데이터와 함수의 결합(구조체+함수)
---

## 3.변수와 메서드
---
	1. 선언 위치에 따른 변수의 종류
	- 클래스 변수	: 클래스영역 ex) static int cv;	: 클래스가 메모리에 올라갈때
	- 인스턴스 변수	: 클래스영억 		: 인스턴스가 생성되었을때
	- 지역변수 	: 메서드영역		: 변수 선언문이 수행되었을때
	
 	2. 클래스변수와 인스턴스 변수
	 "인스턴스 변수는 인스턴스가 생성될 떄 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할수 있지만
	클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 갖는다."

	3.메서드
	 특정 작업을 하는 문장들을 하나로 묶은것
	메서드를 사용하는 이유
		1. 높은 재사용성
			메서드는 한번만들면 몇번이든 호출 가능함
		2. 중복된 코드의 제거	
			같은 작업을 반복할필요없이 메서드를 호출하면 중복을 줄일수 있다.
		3.프로그램의 구조화
			문장들을 작업단위로 나누어 여러 개의 메서드를 담아 구조를 단순화 가 팁작업에 필수적이다.

	4. 메서드의 선언과 구현
	선언부 구현부 로 이루어져있음
	- 선언부 : 메서드의 이름, 매개변수 선언, 반환타입
		int(반환타입) add(메서드의 이름)(int x, int y)(매개변수 선언){
			구현부
		}

	-return문
	메서드의 반환타입이 void가 아닌경우 구현부 안에 return 반환값 이 반듯이 포함 되어야 한다.
	 return 반환값 은 작업을 수행한 결과인 반환값을 호출한 메서드로 전달하는대 이 값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능해야 한다.(반환값 유무에 관계없이 모든 메서드에는 적어도 하나의 return문이 있어야 한다. void의 경우 자동으로 return을 해주었기때문에 문제가 없었다.)

	5. 메서드의 호출
		메서드이름(값1,값2...);
		메서드 호출하는법
	
	인자와 매개변수
	괄호()안에 지정값을 인자 또는 인수라고 하며 인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야 한다.
	
	
	6. JVM의 메모리 구조
		3가지 주요 영역
			method Area	: 클래스파일을 읽어서 분석하여 클래스에 대한 정보를 저장 클래스변수도 함께 생성
			Call stack		: 호출스택은 메서드의 작업에 필요한 메모리 공간 제공, 메서드 작업수행중 지역변수들과 연산의 중간결과등을 저장하는대 사용
			Heap		: 인스턴스가 생성되는 공간,인스턴스 변수들이 생성되는 공간
			
			-호출스택(Call stack)의 특징
				- 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
				- 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거 된다.
				- 호출스택의 제일 위에 있는 메서드가 현재 실행중인 메서드이다.
				- 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

	 7. 기본형과 참조형 매개변수
		기본형(primitive type) : 변수의 값을 읽기만 가능 
		참조형(referrence type) : 변수의 값을 읽고 변경할수있다. 
		
	
	8. 참조형 반환타입
		반환타입도 참조형이 될수있다. 참조형타입의 값은 객체의 주소 이므로 그저 정수값이 반환되는 것.

	9. 재귀호출(recursive call)
		메서드 내부에서 메서드 자신을 다시 호출하는것 그러한 메서드를 재귀 매서드라 한다.
		
		무한 반복을 하지 않게 조건문과 함께 사용해야함
		
		대부분의 재귀호출은 반복문으로 작성가능함.
	
	10. 클래스 매서드(static메서드)와 인스턴스 메서드
		클래스 매서드 : 클래스변수처럼 객체를 생성하지 않고도 클래스이름.메서드이름 과 같은식으로 호출 가능
		인스턴스메서드 : 반드시 객체를 생성해야만 호출 가능
		 1. 클래스를 설계할때, 맴버변수중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
		 2. 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
		 3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
		 4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

	

	11. 클래스 멤버와 인스턴스 멤버간의 참조와 호출
		클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자하는 경우에는 인스턴스를 생성해야 한다.
			- 인스턴스 멤버가 존재하는 경우에는 클래스 멤버는 항상 존재하지만 반대의 경우에는 아닐경우가 있기때문이다.

 
 4. 오버로딩
	1. 오버로딩
		한 클래스 내에 같은 이름의 다른타입의 메서드를 여러개 정의하는것
	
	2. 오버로딩의 조건
		1. 메서드 이름이 같아야 한다.
		2. 매개변수의 개수 또는 타입이 달라야 한다.
	3. 오버로딩의 장점
		기능이 같지만 매개변수가 다른 경우 여러 이름의 메서드를 기억할필요가 없어짐

	4. 가변인자 오버로딩
		메서드 매개변수를 동적으로 지정할수있는 기능(JDK1.5부터 가능)
		"타입... 변수명" 과 같은 형식으로 지정
	

 5. 생성자
	1. 생성자	
		인스턴스가 생성될때 호출되는 '인스턴스 초기화 메서드'
	생성 조건
		1. 생성자의 이름은 클래스의 이름과 같아야 한다.
		2. 생성자는 리턴 값이 없다.

		연산자 new가 인스턴스를 생성 , 생성자가 인스턴스를 생성하는것이 아님
		생성자는 인스턴스변수들의 초기화에 사용됨

	2. 기본 생성자(default constructor)
		모든 클래스에는 반드시 하나 이상의 생성자가 정의 되야함
		하지만 컴파일러가 제공하는 기본 생성자가 있어 정의하지 않아도 인스턴스를 생성할수 있었음
			클래스이름() {}
		위와같이 아무런 내용이 없는 생성자를 컴파일러가 기본으로 제공해줌
		
		"기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다"
	
	3. 매개변수가 있는 생성자
		매개변수를 선언하여 호출 시 값을 넘겨받아서 인스턴스의 초기화 작업에 사용가능

		class Car{
			String color;
			String gearType;
			int door;
			
			Car(){}//생성자
			Car(String c,String g,int d){
			color = c;
			gearType = g;
			door= d;
			}
		}
		와 같이 매개변수가 있는 생성자를 사용하면 생성과 동시에 원하는 값으로 초기화가 가능하다.

	
	4. 생성자에서 다른 생성자 호출하기- this().this
		- 생성자의 이름으로 클래스이름 대신 this를 사용한다.
		- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

	
	5. 생성자를 이용한 인스턴스의 복사
		현재 사용하고 있는 인스턴스와 같은 상태를 갖는 인스턴스를 하나 더 만들고자 할 때 생성자를 이용할 수 있다.
		두 인스턴스가 같은 상태라는 것은 두 인스턴스의 모든 인스턴스 변수가 동일한 값이라는 뜻이다.

	
 6. 변수의 초기화
	1. 변수의 초기화
		지역변수는 사용전에 반드시 초기화 해야함 		
	"멤버변수(클래스와 인스턴스 변수)와 배열의 초기화는 선택적 이지만 
		지역변수의 초기화는 필수적이다. "
	- 멤버면수 초기화 방법
		1. 명시적 초기화
		2. 생성자
		3. 초기화 블럭
			- 인스턴스 초기화 블럭
			- 클래스 초기화 블럭
		
	2. 명시적 초기화
		변수 선언과 동시에 초기화 해주는것
		
	3. 초기화 블럭
		- 인스턴스 초기화 블럭 
		- 클래스 초기화 블럭 
		둘다 복잡한 초기화에 사용된다.
		static {/*클래스 초기화 블럭*/}
		{/*인스턴스 초기화 블럭*/}
		모든 생성자에 공통으로 수행되어야 하는 문장을 따로 빼 인스턴스 혹은 클래스 초기화 블럭으로 만들면 된다. 
	
	4. 멤버변수의 초기화 시기와 순서
		클래스 변수의 초기화 시점 	: 클래스가 처음 로딩될때 단 한번 초기화
		인스턴스 변수의 초기화 시점 	: 인스턴스가 생성될 떄마다 각 인스턴스별로 초기화
		클래스 변수의 초기화순서 	: 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭	
		인스턴스 변수의 초기화순서 	: 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자
